<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#
    var fieldDetailsList = GetFieldDetailsList();
    var componentDetails = GetComponentDetails();
    var generatedHeader = CommonGeneratorUtils.GetGeneratedHeader();
    var componentNamespace = qualifiedNamespace + "." + componentDetails.ComponentName;
#>
<#= generatedHeader #>

using Improbable.Gdk.Core;
using Improbable.Worker.Core;
using System;
using System.Collections.Generic;
using Unity.Entities;

namespace <#= qualifiedNamespace #>
{
    public partial class <#= componentDetails.ComponentName  #>
    {
        public const uint ComponentId = <#= componentDetails.ComponentId #>;

        public struct Component : IComponentData, ISpatialComponentData
        {
            public uint ComponentId => <#= componentDetails.ComponentId #>;

            private BlittableBool isDirty;

            // Bit masks for tracking which component properties were changed locally and need to be synced.
            // Each byte tracks 8 component properties.
<# for (var i = 0; i < (fieldDetailsList.Count / 8) + 1; i++) { #>
            private byte dirtyBits<#= i #>;
<# } #>

            public bool IsDirty()
            {
                return isDirty;
            }

            /*
            The propertyIndex arguments starts counting from 0. It depends on the order of which you defined
            your component properties in a schema component but is not the schema field number itself. E.g.
            component MyComponent
            {
                id = 1337;
                bool val_a = 1;
                bool val_b = 3;
            }
            In that case, val_a uses propertyIndex 0 and val_b uses propertyIndex 1 in this method.
            */
            public bool IsDirty(int propertyIndex)
            {
                if (propertyIndex < 0 || propertyIndex >= <#= fieldDetailsList.Count #>)
                {
                    throw new ArgumentException("propertyIndex argument out of range.");
                }

                var byteBatch = propertyIndex / 8;
                switch (byteBatch)
                {
<# for (var i = 0; i < (fieldDetailsList.Count / 8) + 1; i++) { #>
                    case <#= i #>:
                        return (dityBits<#= i #> & (0x1 << propertyIndex % 8)) != 0x0;
<# } #>
                    default:
                        throw new ArgumentException("propertyIndex argument out of range.");
                }
            }

            // like the IsDirty() method above, the propertyIndex arguments starts counting from 0.
            public void MarkDirty(int propertyIndex)
            {
                if (propertyIndex < 0 || propertyIndex >= <#= fieldDetailsList.Count #>)
                {
                    throw new ArgumentException("propertyIndex argument out of range.");
                }

                var byteBatch = propertyIndex / 8;
                switch (byteBatch)
                {
<# for (var i = 0; i < (fieldDetailsList.Count / 8) + 1; i++) { #>
                    case <#= i #>:
                        dityBits<#= i #> |= (byte) (0x1 << propertyIndex % 8);
                        break;
<# } #>
                    default:
                        throw new ArgumentException("propertyIndex argument out of range.");
                }

                isDirty = true;
            }

            public void MarkNotDirty()
            {
<# for (var i = 0; i < (fieldDetailsList.Count / 8) + 1; i++) { #>
                dityBits<#= i #> = 0x0;
<# } #>
                isDirty = false;
            }
<# for (var i = 0; i < fieldDetailsList.Count; i++) {
var fieldDetails = fieldDetailsList[i]; #>
<# if (fieldDetails.IsBlittable) { #>

            private <#= fieldDetails.Type #> <#= fieldDetails.CamelCaseName #>;

            public <#= fieldDetails.Type #> <#= fieldDetails.PascalCaseName #>
            {
                get => <#= fieldDetails.CamelCaseName #>;
                set
                {
                    MarkDirty(<#= i #>);
                    <#= fieldDetails.CamelCaseName #> = value;
                }
            }
<# } else { #>

            internal uint <#= fieldDetails.CamelCaseName #>Handle;

            public <#= fieldDetails.Type #> <#= fieldDetails.PascalCaseName #>
            {
                get => <#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= fieldDetails.PascalCaseName #>Provider.Get(<#= fieldDetails.CamelCaseName #>Handle);
                set
                {
                    MarkDirty(<#= i #>);
                    <#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= fieldDetails.PascalCaseName #>Provider.Set(<#= fieldDetails.CamelCaseName #>Handle, value);
                }
            }
<# } #>
<# } #>

<# if (!UnityTypeMappings.WellKnownComponents.Contains(componentDetails.ComponentId)) { #>
            public static global::Improbable.Worker.Core.ComponentData CreateSchemaComponentData(
<# foreach(var fieldDetails in fieldDetailsList) {
    var lastItem = fieldDetailsList[fieldDetailsList.Count - 1];
#>
                <#= fieldDetails.Type #> <#= fieldDetails.CamelCaseName #><#= lastItem != fieldDetails ? "," : "" #>
<# } #>
        )
            {
                var schemaComponentData = new global::Improbable.Worker.Core.SchemaComponentData(<#= componentDetails.ComponentId #>);
                var obj = schemaComponentData.GetFields();
<# foreach (var fieldDetails in fieldDetailsList) { #>
                {
                    <#= fieldDetails.GetSerializationString(fieldDetails.CamelCaseName, "obj", 4) #>
                }
<# } #>
                return new global::Improbable.Worker.Core.ComponentData(schemaComponentData);
            }
<# } #>
        }

        public static class Serialization
        {
            public static void SerializeUpdate(<#= componentNamespace #>.Component component, global::Improbable.Worker.Core.SchemaComponentUpdate updateObj)
            {
                var obj = updateObj.GetFields();
<# for (var i = 0; i < fieldDetailsList.Count; i++) {
var fieldDetails = fieldDetailsList[i]; #>
                {
                    if (component.IsDirty(<#= i #>))
                    {
                        <#= fieldDetails.GetSerializationString("component." + fieldDetails.PascalCaseName, "obj", 5) #>
                    }

<# if (ShouldGenerateClearedFieldsSet()) { #>
                    <#= fieldDetails.GetTrySetClearedFieldString("component." + fieldDetails.PascalCaseName, "updateObj", 5) #>
<# } #>
                }
<# } #>
            }

            public static <#= componentNamespace #>.Component Deserialize(global::Improbable.Worker.Core.SchemaObject obj, global::Unity.Entities.World world)
            {
                var component = new <#= componentNamespace #>.Component();

<# foreach (var fieldDetails in fieldDetailsList) { #>
<# if (!fieldDetails.IsBlittable) { #>
                component.<#= fieldDetails.CamelCaseName#>Handle = <#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.ReferenceTypeProviders.<#= fieldDetails.PascalCaseName #>Provider.Allocate(world);
<# } #>
                {
                    <#= fieldDetails.GetDeserializeString("component." + fieldDetails.PascalCaseName, "obj", 5) #>
                }
<# } #>
                return component;
            }

            public static <#= componentNamespace #>.Update DeserializeUpdate(global::Improbable.Worker.Core.SchemaComponentUpdate updateObj)
            {
                var update = new <#= componentNamespace #>.Update();
                var obj = updateObj.GetFields();

<# if (ShouldGenerateClearedFieldsSet()) { #>
                var clearedFields = updateObj.GetClearedFields();

<# } #>
<# foreach (var fieldDetails in fieldDetailsList) { #>
                {
                    <#= fieldDetails.GetDeserializeUpdateIntoUpdateString("update." + fieldDetails.PascalCaseName, "obj", 5) #>
                }
<# } #>
                return update;
            }

            public static void ApplyUpdate(global::Improbable.Worker.Core.SchemaComponentUpdate updateObj, ref <#= componentNamespace #>.Component component)
            {
                var obj = updateObj.GetFields();

<# if (ShouldGenerateClearedFieldsSet()) { #>
                var clearedFields = updateObj.GetClearedFields();

<# } #>
<# foreach (var fieldDetails in fieldDetailsList) { #>
                {
                    <#= fieldDetails.GetDeserializeUpdateString("component." + fieldDetails.PascalCaseName, "obj", 5) #>
                }
<# } #>
            }
        }

        public struct Update : ISpatialComponentUpdate
        {
            internal static Stack<List<Update>> Pool = new Stack<List<Update>>();

<# foreach(var fieldDetails in fieldDetailsList) { #>
            public Option<<#= fieldDetails.Type #>> <#= fieldDetails.PascalCaseName #>;
<# } #>
        }

        public struct ReceivedUpdates : IComponentData
        {
            internal uint handle;
            public global::System.Collections.Generic.List<Update> Updates
            {
                get => <#= qualifiedNamespace #>.<#= componentDetails.ComponentName #>.ReferenceTypeProviders.UpdatesProvider.Get(handle);
            }
        }

        internal class <#= componentDetails.ComponentName  #>Dynamic : IDynamicInvokable
        {
            public uint ComponentId => <#= componentDetails.ComponentName  #>.ComponentId;

            private static Component DeserializeData(ComponentData data, World world)
            {
                var schemaDataOpt = data.SchemaData;
                if (!schemaDataOpt.HasValue)
                {
                    throw new ArgumentException($"Can not deserialize an empty {nameof(ComponentData)}");
                }

                return Serialization.Deserialize(schemaDataOpt.Value.GetFields(), world);
            }

            private static Update DeserializeUpdate(ComponentUpdate update, World world)
            {
                var schemaDataOpt = update.SchemaData;
                if (!schemaDataOpt.HasValue)
                {
                    throw new ArgumentException($"Can not deserialize an empty {nameof(ComponentUpdate)}");
                }

                return Serialization.DeserializeUpdate(schemaDataOpt.Value);
            }

            public void InvokeHandler(Dynamic.IHandler handler)
            {
                handler.Accept<Component, Update>(<#= componentDetails.ComponentName  #>.ComponentId, DeserializeData, DeserializeUpdate);
            }
        }
    }
}
